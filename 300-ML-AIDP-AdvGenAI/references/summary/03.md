### 지표들

1️⃣ 성능 관점 (Performance Metrics)

- 응답성능

| 지표                           | 의미            | 왜 중요한가           |
| ---------------------------- | ------------- | ---------------- |
| **Request Start / End Time** | 요청 시작·종료 시각   | SLA 추적, 장애 시점 분석 |
| **TTFT**                     | 첫 토큰까지 시간     | 체감 사용자 경험의 핵심    |
| **End-to-End Latency**       | 전체 처리 시간      | 서비스 품질(SLO) 판단   |
| **Streaming Duration**       | 스트리밍 응답 지속 시간 | 대화 UX 품질         |

- 처리량 & 안정성

| 지표                             | 의미          | 왜 중요한가     |
| ------------------------------ | ----------- | ---------- |
| **Requests per Second (RPS)**  | 처리 가능한 요청 수 | 확장성 판단     |
| **Error Rate (4xx/5xx)**       | 오류 발생 비율    | 신뢰성 지표     |
| **Retry Count**                | 재시도 횟수      | 외부 의존성 안정성 |
| **Graceful Degradation 발생 횟수** | 기능 축소 동작    | 장애 대응 성숙도  |

- 비용 효율

| 지표                               | 의미      | 왜 중요한가      |
| -------------------------------- | ------- | ----------- |
| **Input Tokens / Output Tokens** | 토큰 사용량  | 비용 산정의 핵심   |
| **Cost per Query**               | 요청당 비용  | 비즈니스 KPI 연결 |
| **Prompt Length**                | 프롬프트 크기 | 컨텍스트 최적화 판단 |
| **Context Compression Ratio**    | 압축 비율   | 비용·성능 균형    |


2️⃣ 거버넌스 관점 (Governance Metrics)

- 프롬프트 수명주기 관리

| 지표                    | 의미                   | 왜 중요한가   |
| --------------------- | -------------------- | -------- |
| **Prompt Version ID** | 프롬프트 고유 버전           | 재현성·감사   |
| **Approval Status**   | 승인 여부                | 무단 변경 방지 |
| **Deployment Stage**  | Dev / Staging / Prod | 변경 통제    |
| **Rollback Count**    | 롤백 횟수                | 품질 문제 신호 |



### TTFT를 측정

```python
def invoke_bedrock_with_ttft(prompt: str):
    # 1️⃣ 요청 시작 시각
    request_start_time = time.time()
    first_token_time = None

    response_stream = bedrock.invoke_model_with_response_stream(
        modelId="anthropic.claude-3-sonnet-20240229-v1:0",
        body={
            "anthropic_version": "bedrock-2023-05-31",
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "max_tokens": 512,
            "temperature": 0.2
        }
    )

    # 2️⃣ 스트리밍 응답 처리
    for event in response_stream["body"]:
        if "chunk" in event:
            chunk = event["chunk"]
            chunk_text = chunk.get("bytes", b"").decode("utf-8")

            # 3️⃣ 첫 토큰 수신 시각 기록
            if first_token_time is None and chunk_text.strip():
                first_token_time = time.time()
                break  # TTFT만 측정하면 이후는 필요 없음

    # 4️⃣ TTFT 계산
    if first_token_time is None:
        raise RuntimeError("First token not received")

    ttft_ms = (first_token_time - request_start_time) * 1000
    return ttft_ms


def publish_ttft_metric(ttft_ms: float):
    cloudwatch.put_metric_data(
        Namespace="LLM/Performance",
        MetricData=[
            {
                "MetricName": "TTFT",
                "Value": ttft_ms,
                "Unit": "Milliseconds",
                "Dimensions": [
                    {
                        "Name": "Model",
                        "Value": "claude-3-sonnet"
                    }
                ]
            }
        ]
    )

prompt = "Explain TTFT in simple terms."

ttft = invoke_bedrock_with_ttft(prompt)
publish_ttft_metric(ttft)

print(f"TTFT: {ttft:.2f} ms")

```

